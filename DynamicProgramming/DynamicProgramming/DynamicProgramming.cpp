#include<iostream>
#include<vector>
#include"CutRod.h"
#include"MatrixChain.h"
#include"LCS.h"
using namespace std;


int main(){

	////////钢条切割问题
	////////钢条切割问题求长度为n的钢条的最佳收益及切割方案
	////////n表示钢条长度，p表示钢条为1~10时的收益值
	////////r为输出，表示钢条长为0~10时，各自的最佳切割收益
	////////s为解，表示长为n的钢条在达到最佳收益时第一段的切割长度
	int n1 = 10;
	int p1[10] = {1,5,8,9,10,17,17,20,24,30};
	int r1[11] = {0};
	int s1[11] = {0};
	//自底向上的方法
	bottom_up_cut_rod(p1,n1,r1,s1);
	//自顶向下的带备忘的方法
	//up_bottom_cut_rod(p,n,r,s);
	//输出结果
	cut_rod_print(n1,r1,s1);


	////////矩阵链乘法问题
	////////矩阵链乘法问题是求1~n个矩阵相乘的最小代价问题
	////////n表示矩阵长度
	////////p表示矩阵阶数
	////////m为最优代价，其下标为i,j,m[i][j]表示了Ai~Aj矩阵的最低代价
	////////s为最优解，其下标为i,j,s[i][j]表示了在改位置处画分割括号，则Ai~Aj的乘法将达到最低代价
	cout<<endl;
	cout<<"矩阵乘法问题："<<endl;
	int n2 = 6;						   //6个矩阵
	int p2[7] = {30,35,15,5,10,20,25};  //矩阵阶数，共6个矩阵相乘
	int m2[7][7] = {0};                 //最优代价
	int s2[7][7] = {0};                 //最优解
	//自底向上的方法
	matirx_chain_order(p2,n2,m2,s2);
	cout<<"6个矩阵相乘的最低代价为：";
	cout<<m2[1][6]<<endl;
	cout<<"最优括号化方案为：";
	matrix_chian_print(s2,1,6);
	cout<<endl;


	////////最长公共子序列
	////////最长公共子序列是求两个序列的最长公共子序列
	////////两个序列为x和y
	////////其长度分别为m和n
	////////输出结果即为两序列的最长公共子序列
	cout<<endl;
	cout<<"最长公共子序列问题："<<endl;
	int m = 7;
	int n = 6;
	char x[7] = {'A','B','C','B','D','A','B'};
	char y[6] = {'B','D','C','A','B','A'};
	cout<<"序列X为：";
	for(int i=0;i<m;i++)
		cout<<x[i];
	cout<<endl;
	cout<<"序列Y为：";
	for(int i=0;i<n;i++)
		cout<<y[i];
	cout<<endl;
	int c[8][7] = {0};
	LCS_length(x,y,m,n,c);
	cout<<"最长公共子序列长度为：";
	cout<<c[m][n]<<endl;
	cout<<"最长公共子序列为：";
	LCS_print(x,y,m,n,c);
	cout<<endl;

	
	return 0;
}